(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{520:function(a,s,t){"use strict";t.r(s);var r=t(6),e=Object(r.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("当需要针对垃圾回收进行优化时，可以考虑从以下几点思路出发。")]),a._v(" "),t("h2",{attrs:{id:"_1-对象进入老年代的规则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-对象进入老年代的规则"}},[a._v("#")]),a._v(" 1. 对象进入老年代的规则")]),a._v(" "),t("ul",[t("li",[a._v("根据 "),t("strong",[a._v("【对象进入老年代的规则】")]),a._v(", 主要有以下思路")])]),a._v(" "),t("h3",{attrs:{id:"_1-1-避免过早进入老年代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-避免过早进入老年代"}},[a._v("#")]),a._v(" 1.1 避免过早进入老年代")]),a._v(" "),t("ul",[t("li",[a._v("简单来说就是尽量让每次【Minor GC】后的存活对象小于Survivor区的50%")]),a._v(" "),t("li",[a._v("避免因为动态年龄判断机制而过早进入老年代，尽量都存活在年轻代中，尽量减少Full GC的频率，Full GC对JVM性能的影响很严重")]),a._v(" "),t("li",[a._v("这种情况容易出现在高并发的系统\n"),t("ul",[t("li",[a._v("正常情况下每秒创建的对象都是很少的，但是某一时间段，并发量突然上升，导致新对象创建的过快")]),a._v(" "),t("li",[a._v("此时很容易因为动态年龄判断机制过早的进入老年代")]),a._v(" "),t("li",[a._v("所以这种情况下，要调整年轻代的大小，让这些对象都尽可能的留在年轻代，因为这些都是朝生夕死的对象")])])])]),a._v(" "),t("h3",{attrs:{id:"_1-2-大对象尽早进入老年代"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-大对象尽早进入老年代"}},[a._v("#")]),a._v(" 1.2 大对象尽早进入老年代")]),a._v(" "),t("ul",[t("li",[a._v("大对象，如: 【需要大量连续内存空间的对象 比如字符串、数组】")]),a._v(" "),t("li",[a._v("因为年轻代用的是标记-复制算法，大对象在复制的时候会消耗大量的性能，所以要尽早的进入老年代")])]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("使用-XX:PretenureSizeThreshold设置大小，超过这个大小的对象直接进入老年代，不会进入年轻代。\n这个参数只在Serial和ParNew两个GC收集器下有用\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br")])]),t("h2",{attrs:{id:"_2-频繁发生【full-gc】"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-频繁发生【full-gc】"}},[a._v("#")]),a._v(" 2. 频繁发生【Full GC】")]),a._v(" "),t("ul",[t("li",[a._v("除了正常的因为老年代空间不足而发生Full GC，还有老年代空间担保机制的存在，")]),a._v(" "),t("li",[a._v("【老年代空间担保机制】\n"),t("ul",[t("li",[a._v("年轻代在每次Minor GC之前，JVM都会计算下老年代剩余可用空间")]),a._v(" "),t("li",[a._v("如果这个可用空间小于年轻代里现有的所有对象大小之和，就会看一个 -XX:-HandlePromotionFailure JDK1.8默认设置参数是否设置")]),a._v(" "),t("li",[a._v("这个参数就是一个担保参数，担保一下")]),a._v(" "),t("li",[a._v("如果老年代剩余空间小于历史每一次Minor GC后进入老年代的对象的平均值，就会先发生一次Full GC，再执行Minor GC，Minor GC后，老年代不够又会发生Full GC")]),a._v(" "),t("li",[a._v("这样【一次完整的Minor GC】 = 【两次Full GC】 + 【一次Minor GC】")])])]),a._v(" "),t("li",[a._v("元空间不够会导致多余的Full GC，导致Full GC次数频繁")]),a._v(" "),t("li",[a._v("显示调用System.gc造成多余的Full GC\n"),t("ul",[t("li",[a._v("这种一般线上尽量通过 -XX:+DisableExplicitGC参数禁用，")]),a._v(" "),t("li",[a._v("加上这个参数，System.gc就没有任何效果")])])])]),a._v(" "),t("h2",{attrs:{id:"_3-案例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-案例"}},[a._v("#")]),a._v(" 3. 案例")]),a._v(" "),t("h3",{attrs:{id:"_3-1-线上发生频繁的full-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-线上发生频繁的full-gc"}},[a._v("#")]),a._v(" 3.1 线上发生频繁的Full GC")]),a._v(" "),t("h4",{attrs:{id:"_3-1-1-环境背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-环境背景"}},[a._v("#")]),a._v(" 3.1.1 环境背景")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("使用以下JVM参数，用于"),t("strong",[a._v("模拟真实场景下的JVM环境")])]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Xms2048M")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Xmx2048M")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Xmn512M")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Xss256K")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SurvivorRatio")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MetaspaceSize")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("256")]),a._v("M "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MaxMetaspaceSize")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("256")]),a._v("M "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseParNewGC")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseConcMarkSweepGC")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("CMSInitiatingOccupancyFraction")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("75")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("XX"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("UseCMSInitiatingOccupancyOnly")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])])]),a._v(" "),t("li",[t("p",[a._v("各项参数含义说明:")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("-Xms2048M：设置JVM初始堆内存为2048M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。")])]),a._v(" "),t("li",[t("p",[a._v("-Xmx2048M：设置JVM堆内存最大为2048M")])]),a._v(" "),t("li",[t("p",[a._v("-Xmn512M：设置年轻代大小为512M")])]),a._v(" "),t("li",[t("p",[a._v("-Xss256K：设置每个线程的线程栈大小为256K")])]),a._v(" "),t("li",[t("p",[a._v("-XX:SurvivorRatio=6：设置Eden区的比例。设置为6，则表示 Eden:S0:S1 = 6:2:2。【该参数默认为8】")])]),a._v(" "),t("li",[t("p",[a._v("-XX:MetaspaceSize=256M：设置元空间大小为256M")])]),a._v(" "),t("li",[t("p",[a._v("-XX:MaxMetaspaceSize=256M：设置最大元空间大小为256M")])]),a._v(" "),t("li",[t("p",[a._v("-XX:+UseParNewGC：设置年轻代垃圾回收器是ParNew")])]),a._v(" "),t("li",[t("p",[a._v("-XX:+UseConcMarkSweepGC：设置老年代垃圾回收器是CMS")])]),a._v(" "),t("li",[t("p",[a._v("-XX:CMSInitiatingOccupancyFraction=75：设置CMS在对老年代内存使用率达到75%的时候开始GC，"),t("strong",[a._v("因为CMS会有浮动垃圾,所以一般都较早启动GC")])])]),a._v(" "),t("li",[t("p",[a._v("-XX:+UseCMSInitiatingOccupancyOnly：只用设置的回收阈值"),t("strong",[a._v("上面指定的75%")]),a._v(",如果不指定,JVM"),t("strong",[a._v("仅在第一次使用设定值")]),a._v(",后续则自动调整,一般和上一个命令组合使用")])])])])]),a._v(" "),t("h4",{attrs:{id:"_3-1-2-情况1-由于动态年龄判断机制导致的频繁full-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-情况1-由于动态年龄判断机制导致的频繁full-gc"}},[a._v("#")]),a._v(" 3.1.2  情况1:  由于动态年龄判断机制导致的频繁Full GC")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("由于"),t("strong",[a._v("动态年龄判断机制的原因")]),a._v("导致的频繁发生Full GC，应该怎么调优呢，我们先从以下几个方面来看")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("动态年龄判断机制")]),a._v("的关键点在于年轻代的空间大小，所以首先就是要把年轻代的空间调大")]),a._v(" "),t("li",[a._v("如果是并发量大的系统，我们可以调小"),t("strong",[a._v("CMSInitiatingOccupancyFraction")]),a._v("设定的值，避免产生"),t("strong",[a._v("Serial Old收集器的情况")])]),a._v(" "),t("li",[a._v("但是如果是并发量小的系统，我们可以调大"),t("strong",[a._v("CMSInitiatingOccupancyFraction")]),a._v("设定的值，充分利用堆空间")])])]),a._v(" "),t("li",[t("p",[a._v("按照以下进行参数调整")]),a._v(" "),t("ul",[t("li",[a._v("把年轻代的空间调大成1536M 这样老年代的空间就是512M")]),a._v(" "),t("li",[a._v("把CMS老年代内存使用阈值调大成90% 充分利用老年代的空间，如果并发量大的系统， 有可能需要调低这个值 ，避免最后因为并发冲突导致使用Serial Old收集器")])])]),a._v(" "),t("li",[t("p",[a._v("调整后的参数如下:")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("-Xms2048M -Xmx2048M -Xmn1536M -Xss256K -XX:SurvivorRatio=6 -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=90 -XX:+UseCMSInitiatingOccupancyOnly\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])])])]),a._v(" "),t("h4",{attrs:{id:"_3-1-3-情况2-由于老年代空间担保机制导致的频繁full-gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-3-情况2-由于老年代空间担保机制导致的频繁full-gc"}},[a._v("#")]),a._v(" 3.1.3 情况2: 由于老年代空间担保机制导致的频繁FUll GC")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("如果按照上面设置，把老年代设置小的话，很容易会因为"),t("strong",[a._v("老年代空间担保机制")]),a._v("，导致频繁的发生Full GC")])]),a._v(" "),t("li",[t("p",[t("strong",[a._v("老年代空间担保机制")]),a._v("的关键点在于每次Minor GC的时候进入老年代对象的平均大小，所以我们要控制"),t("strong",[a._v("每次Minor GC后进入老年代的对象平均大小")])])])]),a._v(" "),t("h5",{attrs:{id:"判断内存中对象的分布情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断内存中对象的分布情况"}},[a._v("#")]),a._v(" 判断内存中对象的分布情况")]),a._v(" "),t("ul",[t("li",[a._v("使用jmap -histo 进程号的命令，观察内存中对象的分布情况")]),a._v(" "),t("li",[a._v("观察有没有比较集中的对象，因为如果是并发量高的系统，接口方法很有可能是集中的，创建的对象也是集中的")]),a._v(" "),t("li",[a._v("也就是【热点方法】、【内存占用】比较多的对象这两个方面去分析")]),a._v(" "),t("li",[a._v("借助jvisualvm的抽样器寻找热点方法【"),t("strong",[a._v("jdk8有 jdk11不支持")]),a._v("】")])]),a._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241205141129223.png",alt:"image-20241205141129223"}})]),a._v(" "),t("ul",[t("li",[a._v("借助jmap -histo 进程号观察占用内存比较多的对象")]),a._v(" "),t("li",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241205141400370.png",alt:"image-20241205141400370"}})])]),a._v(" "),t("h5",{attrs:{id:"优化方向"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化方向"}},[a._v("#")]),a._v(" 优化方向")]),a._v(" "),t("ul",[t("li",[a._v("如果是循环创建对象的话，尽量控制循环次数比如每次查询5000条记录【结合实际对象大小】\n"),t("ul",[t("li",[a._v("这些记录如果加载到内存就是要创建不少的对象")]),a._v(" "),t("li",[a._v("如果这批对象经过Minor GC，很容易由于老年代空间分配担保机制，发生Full GC")]),a._v(" "),t("li",[a._v("所以要减少查询记录条数，从而减少创建的对象")])])]),a._v(" "),t("li",[a._v("最快也是最有效的办法，在预算允许的情况下，增加物理机器的配置，增大整个堆的内存")])])])}),[],!1,null,null,null);s.default=e.exports}}]);