(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{526:function(n,e,s){"use strict";s.r(e);var i=s(6),t=Object(i.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h2",{attrs:{id:"场景描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景描述"}},[n._v("#")]),n._v(" 场景描述")]),n._v(" "),s("ul",[s("li",[n._v("项目开发过程中遇到了需要优先加载某个bean的需求，如下:")])]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\n/**\n * 系统属性服务\n**/\n@Service\npublic class SystemConfigService {\n\n    // 访问 db 的 mapper\n    private final SystemConfigMapper systemConfigMapper;\n\n    // 存放一些系统配置的缓存 map\n    private static Map<String, String>> SYS_CONF_CACHE = new HashMap<>()\n\n    // 使用构造方法完成依赖注入\n    public SystemConfigServiceImpl(SystemConfigMapper systemConfigMapper) {\n        this.systemConfigMapper = systemConfigMapper;\n    }\n\n    // Bean 的初始化方法，捞取数据库中的数据，放入缓存的 map 中\n    @PostConstruct\n    public void init() {\n        // systemConfigMapper 访问 DB，捞取数据放入缓存的 map 中\n        // SYS_CONF_CACHE.put(key, value);\n        // ...\n    }\n\n    // 对外提供获得系统配置的 static 工具方法\n    public static String getSystemConfig(String key) {\n        return SYS_CONF_CACHE.get(key);\n    }\n\n    // 省略了从 DB 更新缓存的代码\n    // ...\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br")])]),s("ul",[s("li",[n._v("SystemConfigService 是一个提供了查询系统属性的服务，系统属性存放在 DB 中并且读多写少，在 Bean 创建的时候，通过 @PostConstruct 注解的 init() 方法完成了数据加载到缓存中")]),n._v(" "),s("li",[n._v("最关键的是，由于是系统属性，所以需要在很多地方都想使用，尤其需要在很多 bean 启动的时候使用，为了方便就提供了 static 方法来方便调用，这样其他的 bean 不需要依赖注入就可以直接调用.")]),n._v(" "),s("li",[n._v("但问题是系统属性是存在 db 里面的，这就导致了不能把 SystemConfigService做成一个纯「工具类」，它必须要被 Spring 托管起来，完成 mapper 的注入才能正常工作。")]),n._v(" "),s("li",[n._v("因此这样一来就比较麻烦，其他的类或者 Bean 如果想安全的使用 SystemConfigService#getSystemConfig 中的获取配置的静态方法，就必须等 SystemConfigService 先被 Spring 创建加载起来，完成 init() 方法后才可以。")])]),n._v(" "),s("h2",{attrs:{id:"方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方案"}},[n._v("#")]),n._v(" 方案")]),n._v(" "),s("h3",{attrs:{id:"_1-springboot-官方文档推荐做法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-springboot-官方文档推荐做法"}},[n._v("#")]),n._v(" 1.SpringBoot 官方文档推荐做法")]),n._v(" "),s("p",[n._v("Spring 对于依赖注入更推荐（is preferable）使用构造函数来注入必须的依赖，用 setter 方法来注入可选的依赖。")]),n._v(" "),s("p",[n._v("按照 Spring 的文档，我们应该直接去掉 getSystemConfig 的 static 修饰，让 getSystemConfig 变成一个实例方法，让每个需要依赖的 SystemConfigService 的 Bean 通过构造函数完成依赖注入，这样 Spring 会保证每个 Bean 在创建之前会先把它所有的依赖创建并初始化完成。")]),n._v(" "),s("h3",{attrs:{id:"_2-dependson-注解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-dependson-注解"}},[n._v("#")]),n._v(" 2.@DependsOn 注解")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('\n@Service\n@DependsOn({"systemConfigService"})\npublic class BizService {\n\n    public BizService() {\n        String xxValue = SystemConfigService.getSystemConfig("xxKey");\n        // 可行\n    }\n}\n')])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br")])]),s("p",[n._v("操作起来也太麻烦了，需要让每个每个依赖 SystemConfigService的 Bean 都改代码加上注解")]),n._v(" "),s("h3",{attrs:{id:"_3-applicationcontextinitializer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-applicationcontextinitializer"}},[n._v("#")]),n._v(" 3.ApplicationContextInitializer")]),n._v(" "),s("p",[n._v("第一步：通过 spring.factories 扩展来注册一个 ApplicationContextInitializer：")]),n._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\n# 注册 ApplicationContextInitializer\norg.springframework.context.ApplicationContextInitializer=com.antbank.demo.bootstrap.MyApplicationContextInitializer\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br")])]),s("p",[n._v("注册 ApplicationContextInitializer 的目的其实是为了接下来注册 BeanDefinitionRegistryPostProcessor 到 Spring 中")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("public class MyApplicationContextInitializer implements ApplicationContextInitializer<ConfigurableApplicationContext> {\n    \n    @Override\n    public void initialize(ConfigurableApplicationContext applicationContext) {\n        // 注意，如果你同时还使用了 spring cloud，这里需要做个判断，要不要在 spring cloud applicationContext 中做这个事\n        // 通常 spring cloud 中的 bean 都和业务没关系，是需要跳过的\n        applicationContext.addBeanFactoryPostProcessor(new MyBeanDefinitionRegistryPostProcessor());\n    }\n}\n")])])]),s("p",[n._v("第二步：实现 BeanDefinitionRegistryPostProcessor，注册目标 bean：")]),n._v(" "),s("p",[n._v("用 MyBeanDefinitionRegistryPostProcessor 在 ConfigurationClassPostProcessor 扫描前注册你需要的目标 bean 的 BeanDefinition 即可。")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v('public class MyBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor {\n    \n    @Override\n    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {\n        // 手动注册一个 BeanDefinition\n        registry.registerBeanDefinition("systemConfigService", new RootBeanDefinition(SystemConfigService.class));\n    }\n    \n    @Override\n    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {}\n}\n')])])]),s("h2",{attrs:{id:"问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[n._v("#")]),n._v(" 问题")]),n._v(" "),s("h3",{attrs:{id:"_1-order-注解或者实现-org-springframework-core-ordered-可以实现吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-order-注解或者实现-org-springframework-core-ordered-可以实现吗"}},[n._v("#")]),n._v(" 1. @Order 注解或者实现 org.springframework.core.Ordered 可以实现吗")]),n._v(" "),s("ul",[s("li",[n._v("注解@Order或者接口Ordered的作用是定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序，比如 ApplicationListener，RegistrationBean 等")]),n._v(" "),s("li",[n._v("Bean的加载顺序不受@Order或Ordered接口的影响")])]),n._v(" "),s("h3",{attrs:{id:"_2-autoconfigureorder-autoconfigureafter-autoconfigurebefore-注解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-autoconfigureorder-autoconfigureafter-autoconfigurebefore-注解"}},[n._v("#")]),n._v(" 2. @AutoConfigureOrder/@AutoConfigureAfter/@AutoConfigureBefore 注解")]),n._v(" "),s("p",[n._v("测试下来这些注解也是不可行，它们和 Ordered 一样都是针对 Spring 自身组件 Bean 的执行顺序。")])])}),[],!1,null,null,null);e.default=t.exports}}]);