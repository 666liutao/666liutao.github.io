(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{518:function(v,_,t){"use strict";t.r(_);var a=t(6),i=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("p",[v._v("jdk中自带一系列的监控工具，可以为我们的系统优化，问题排查提供很大的帮助。下面来介绍几个常用的工具。")]),v._v(" "),t("h2",{attrs:{id:"_1-jmap-java内存映像工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-jmap-java内存映像工具"}},[v._v("#")]),v._v(" 1.  jmap (Java内存映像工具)")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("jmap(Memory Map for Java),Java内存映像工具，用于生成堆转储快照,一般称为heapdump或dump文件。")])]),v._v(" "),t("li",[t("p",[v._v("同时它还可以查询finalize执行队列、Java堆和方法区的 详细信息，如空间使用率、当前用的是哪种收集器等。")])]),v._v(" "),t("li",[t("p",[v._v("说简单点就是它能用来查看堆内存信息，"),t("strong",[v._v("诊断和解决内存相关问题，如内存泄露、溢出等问题")])])])]),v._v(" "),t("h3",{attrs:{id:"_1-1-命令语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-命令语法"}},[v._v("#")]),v._v(" 1.1 命令语法")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("jmap [option] [pid]\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("ul",[t("li",[t("p",[v._v("options选项:")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("options")]),v._v(" "),t("th",[v._v("功能描述")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("-dump")]),v._v(" "),t("td",[v._v("生成Java堆转储快照.格式为: -dump:[live,]format=b,file="),t("filename",[v._v(",其中live子参数说明是否只dump出存活的对象")])],1)]),v._v(" "),t("tr",[t("td",[v._v("-finalizerinfo")]),v._v(" "),t("td",[v._v("显示在 F-Queue 中等待 Finalizer 线程执行finalize 方法的对象。")])]),v._v(" "),t("tr",[t("td",[v._v("-heap")]),v._v(" "),t("td",[v._v("显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。")])]),v._v(" "),t("tr",[t("td",[v._v("-histo")]),v._v(" "),t("td",[v._v("显示堆中对象统计信息，包括类、实例数量、合计容量。格式 -histo[:live], 其中live表示只统计展示存活的对象")])]),v._v(" "),t("tr",[t("td",[v._v("-permstat")]),v._v(" "),t("td",[v._v("以 ClassLoader 为统计口径, 显示永久代（PermGen/Metaspace）的统计信息")])]),v._v(" "),t("tr",[t("td",[v._v("-F")]),v._v(" "),t("td",[v._v("当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。")])])])])])]),v._v(" "),t("h3",{attrs:{id:"_1-2-什么是堆dump"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-什么是堆dump"}},[v._v("#")]),v._v(" 1.2 什么是堆dump")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("堆Dump是反应Java堆使用情况的内存镜像")])]),v._v(" "),t("li",[t("p",[v._v("其中主要包括系统信息、虚拟机属性、完整的线程Dump、所有类和对象的状态等。")])]),v._v(" "),t("li",[t("p",[v._v("一般，在内存不足、GC异常等情况下，我们就会怀疑有内存泄漏。这个时候我们就可以制作堆Dump来查看具体情况。分析原因。")])]),v._v(" "),t("li",[t("p",[v._v("常见内存错误")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("outOfMemoryError 年老代内存不足。\noutOfMemoryError:PermGen Space 永久代内存不足。\noutOfMemoryError:GC overhead limit exceed 垃圾回收时间占用系统运行时间的98%或以上。\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br"),t("span",{staticClass:"line-number"},[v._v("3")]),t("br")])])]),v._v(" "),t("li",[t("p",[v._v("可以使用 jvisualvm, mat等工具分析dump文件")])])]),v._v(" "),t("h2",{attrs:{id:"_2-jstack-java堆栈跟踪工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-jstack-java堆栈跟踪工具"}},[v._v("#")]),v._v(" 2. jstack (Java堆栈跟踪工具)")]),v._v(" "),t("ul",[t("li",[v._v("jstack命令用于生成虚拟机当前时刻的线程快照。")]),v._v(" "),t("li",[v._v("线程快照是当前虚拟机内每一条线程正在执行的方法堆栈的集合")]),v._v(" "),t("li",[v._v("生成线程快照的主要目的是定位线程出现长时间停顿的原因， 如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。")])]),v._v(" "),t("h3",{attrs:{id:"_2-1-命令语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-命令语法"}},[v._v("#")]),v._v(" 2.1 命令语法")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("jstack [options] pid\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("table",[t("thead",[t("tr",[t("th",[v._v("options")]),v._v(" "),t("th",[v._v("描述")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("-l")]),v._v(" "),t("td",[v._v("除堆栈外，显示关于锁的附加信息，在发生死锁时可以用jstack -l pid来观察锁持有情况")])]),v._v(" "),t("tr",[t("td",[v._v("-m")]),v._v(" "),t("td",[v._v("打印java和native c/c++框架的所有栈信息。可以打印JVM的堆栈，以及Native的栈帧，一般应用排查不需要使用")])]),v._v(" "),t("tr",[t("td",[v._v("-F")]),v._v(" "),t("td",[v._v("当正常输出的请求不被响应时，强制输出线程堆栈")])])])]),v._v(" "),t("h3",{attrs:{id:"_2-2-死锁案例分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-死锁案例分析"}},[v._v("#")]),v._v(" 2.2 死锁案例分析")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("使用 jstack -l pid 查看线程堆栈信息，信息末尾会有死锁信息打印(如果存在)")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241105181737815.png",alt:"image-20241105181737815"}})])]),v._v(" "),t("li",[t("p",[v._v("上图可以得出以下信息:")]),v._v(" "),t("ul",[t("li",[v._v("线程mythread-tianluo, 正在等待0x000000076b686b80锁，这个锁由mythread-jay线程持有")]),v._v(" "),t("li",[v._v("线程mythread-jay，正在等待0x000000076b686bb0锁，这个锁由mythread-tianluo线程持")])])]),v._v(" "),t("li",[t("p",[v._v("再往上查看对应线程的信息，可以得出更为详细的情况，以及死锁发生的代码位置")])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241105182735968.png",alt:"image-20241105182735968"}})]),v._v(" "),t("ul",[t("li",[v._v("其它字段的一些含义\n"),t("ul",[t("li",[v._v("Thread-1：线程名")]),v._v(" "),t("li",[v._v("prio：优先级")]),v._v(" "),t("li",[v._v("os_prio：操作系统级别的线程优先级")]),v._v(" "),t("li",[v._v("tid：线程id")]),v._v(" "),t("li",[v._v("nid：线程对应本地线程id")]),v._v(" "),t("li",[v._v("java.lang.Thread.State：线程状态")])])])]),v._v(" "),t("h2",{attrs:{id:"_3-jstat-jvm统计信息监视工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-jstat-jvm统计信息监视工具"}},[v._v("#")]),v._v(" 3. jstat (JVM统计信息监视工具)")]),v._v(" "),t("ul",[t("li",[v._v("jstat（Java Virtual Machine Statistics Monitoring Tool）是JDK提供的一个可以监控Java虚拟机各种运行状态信息的命令行工具。")]),v._v(" "),t("li",[v._v("它可以显示Java虚拟机中的类加载、内存、垃圾收集、即时编译等运行状态的信息。")])]),v._v(" "),t("h3",{attrs:{id:"_3-1-命令语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-命令语法"}},[v._v("#")]),v._v(" 3.1 命令语法")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("jstat [generalOptions]\njstat [outputOptions] [-t] [-h<lines>] <vmid> [<interval> [<count>]]\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br"),t("span",{staticClass:"line-number"},[v._v("2")]),t("br")])]),t("h4",{attrs:{id:"_3-1-1-命令参数说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1-命令参数说明"}},[v._v("#")]),v._v(" 3.1.1 命令参数说明")]),v._v(" "),t("ul",[t("li",[t("code",[v._v("generalOptions")]),v._v("：通用选项，如果指定一个通用选项，就不能指定任何其他选项或参数。它包括如下两个选项：\n"),t("ul",[t("li",[t("code",[v._v("-help")]),v._v("：显示帮助信息。")]),v._v(" "),t("li",[t("code",[v._v("-options")]),v._v("：显示"),t("code",[v._v("outputOptions")]),v._v("参数的列表。")])])]),v._v(" "),t("li",[t("code",[v._v("outputOptions")]),v._v("： 输出选项，指定显示某一种Java虚拟机信息")]),v._v(" "),t("li",[t("code",[v._v("-t")]),v._v("：把时间戳列显示为输出的第一列。这个时间戳是从Java虚拟机的开始运行到现在的秒数。")]),v._v(" "),t("li",[t("code",[v._v("-h n")]),v._v("：每显示n行显示一次表头，其中n为正整数。默认值为 0，即仅在第一行数据显示一次表头。")]),v._v(" "),t("li",[t("code",[v._v("vmid")]),v._v("：虚拟机唯一ID（LVMID，Local Virtual Machine Identifier），如果查看本机就是Java进程的进程ID。")]),v._v(" "),t("li",[t("code",[v._v("interval")]),v._v("：显示信息的时间间隔，单位默认毫秒。也可以指定秒为单位，比如：1s。如果指定了该参数，jstat命令将每个这段时间显示一次统计信息。")]),v._v(" "),t("li",[t("code",[v._v("count")]),v._v("：显示数据的次数，默认值是无穷大，这将导致jstat命令一直显示统计信息，直到目标JVM终止或jstat命令终止。")])]),v._v(" "),t("h4",{attrs:{id:"_3-1-2-输出选项"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2-输出选项"}},[v._v("#")]),v._v(" 3.1.2 输出选项")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("outputOptions")]),v._v(" "),t("th",[v._v("描述")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[t("code",[v._v("-class")])]),v._v(" "),t("td",[v._v("显示类加载、卸载数量、总空间和装载耗时的统计信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-compiler")])]),v._v(" "),t("td",[v._v("显示即时编译的方法、耗时等信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gc")])]),v._v(" "),t("td",[v._v("显示堆各个区域内存使用和垃圾回收的统计信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gccapacity")])]),v._v(" "),t("td",[v._v("显示堆各个区域的容量及其对应的空间的统计信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gcutil")])]),v._v(" "),t("td",[v._v("显示有关垃圾收集统计信息的摘要")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gccause")])]),v._v(" "),t("td",[v._v("显示关于垃圾收集统计信息的摘要(与-gcutil相同)，以及最近和当前垃圾回收的原因")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gcnew")])]),v._v(" "),t("td",[v._v("显示新生代的垃圾回收统计信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gcnewcapacity")])]),v._v(" "),t("td",[v._v("显示新生代的大小及其对应的空间的统计信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gcold")])]),v._v(" "),t("td",[v._v("显示老年代和元空间的垃圾回收统计信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gcoldcapacity")])]),v._v(" "),t("td",[v._v("显示老年代的大小统计信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-gcmetacapacity")])]),v._v(" "),t("td",[v._v("显示元空间的大小的统计信息")])]),v._v(" "),t("tr",[t("td",[t("code",[v._v("-printcompilation")])]),v._v(" "),t("td",[v._v("显示即时编译方法的统计信息")])])])]),v._v(" "),t("h3",{attrs:{id:"_3-2-如何解读jstat生成的数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-如何解读jstat生成的数据"}},[v._v("#")]),v._v(" 3.2 如何解读Jstat生成的数据")]),v._v(" "),t("h4",{attrs:{id:"class"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#class"}},[v._v("#")]),v._v(" -class")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("显示字段含义说明")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("Loaded：加载的类的数量。")])]),v._v(" "),t("li",[t("p",[v._v("Bytes：加载的类所占用的字节数。")])]),v._v(" "),t("li",[t("p",[v._v("Unloaded：卸载的类的数量。")])]),v._v(" "),t("li",[t("p",[v._v("Bytes：卸载的类所占用的字节数。")])]),v._v(" "),t("li",[t("p",[v._v("Time：执行类加载和卸载操作所花费的时间。")])])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241106114921864.png",alt:"image-20241106114921864"}})]),v._v(" "),t("h4",{attrs:{id:"compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compiler"}},[v._v("#")]),v._v(" -compiler")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("显示字段含义说明")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("Compiled：执行的编译任务的数量。")])]),v._v(" "),t("li",[t("p",[v._v("Failed：执行编译任务失败的数量。")])]),v._v(" "),t("li",[t("p",[v._v("Invalid：执行编译任务失效的数量。")])]),v._v(" "),t("li",[t("p",[v._v("Time：执行编译任务所花费的时间。")])]),v._v(" "),t("li",[t("p",[v._v("FailedType：上次编译失败的编译类型。")])]),v._v(" "),t("li",[t("p",[v._v("FailedMethod：上次编译失败的类名和方法。")])])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241106115134329.png",alt:"image-20241106115134329"}})]),v._v(" "),t("h4",{attrs:{id:"gc"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gc"}},[v._v("#")]),v._v(" -gc")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("显示字段含义说明")]),v._v(" "),t("ul",[t("li",[v._v("S0C：年轻代中第一个Survivor区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S1C：年轻代中第二个Survivor区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S0U：年轻代中第一个Survivor区已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("S1U：年轻代中第二个Survivor区已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("EC：年轻代中Eden区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("EU：年轻代中Eden区已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("OC：老年代的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OU：老年代已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("MC：元空间的容量，单位为KB。")]),v._v(" "),t("li",[v._v("MU：元空间已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("CCSC：压缩类的容量，单位为KB。")]),v._v(" "),t("li",[v._v("CCSU：压缩类已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("YGCT：Young GC所用的时间。")]),v._v(" "),t("li",[v._v("FGC：Full GC的次数。")]),v._v(" "),t("li",[v._v("FGCT：Full GC的所用的时间。")]),v._v(" "),t("li",[v._v("GCT：GC的所用的总时间。")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241106115323538.png",alt:"image-20241106115323538"}})])])]),v._v(" "),t("h4",{attrs:{id:"gccapacity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gccapacity"}},[v._v("#")]),v._v(" -gccapacity")]),v._v(" "),t("ul",[t("li",[v._v("显示字段含义说明\n"),t("ul",[t("li",[v._v("NGCMN：年轻代最小的容量，单位为KB。")]),v._v(" "),t("li",[v._v("NGCMX：年轻代最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("NGC：当前年轻代的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S0C：年轻代中第一个Survivor区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S1C：年轻代中第二个Survivor区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("EC：年轻代中Eden区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OGCMN：老年代最小的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OGCMX：老年代最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OGC：当前老年代的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OC：当前老年代的容量，单位为KB。")]),v._v(" "),t("li",[v._v("MCMN：元空间最小的容量，单位为KB。")]),v._v(" "),t("li",[v._v("MCMX：元空间最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("MC：当前元空间的容量，单位为KB。")]),v._v(" "),t("li",[v._v("CCSMN：压缩类最小的容量，单位为KB。")]),v._v(" "),t("li",[v._v("CCSMX：压缩类最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("CCSC：当前压缩类的容量，单位为KB。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("FGC：Full GC的次数。")])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241106115559505.png",alt:"image-20241106115559505"}})]),v._v(" "),t("h4",{attrs:{id:"gcutil"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcutil"}},[v._v("#")]),v._v(" -gcutil")]),v._v(" "),t("ul",[t("li",[v._v("显示内容字段含义\n"),t("ul",[t("li",[v._v("S0：年轻代中第一个Survivor区使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("S1：年轻代中第二个Survivor区使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("E：Eden区使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("O：老年代使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("M：元空间使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("CCS：压缩类使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("YGCT：Young GC所用的时间。")]),v._v(" "),t("li",[v._v("FGC：Full GC的次数。")]),v._v(" "),t("li",[v._v("FGCT：Full GC的所用的时间。")]),v._v(" "),t("li",[v._v("GCT：GC的所用的总时间")])])])]),v._v(" "),t("h4",{attrs:{id:"gccause"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gccause"}},[v._v("#")]),v._v(" -gccause")]),v._v(" "),t("ul",[t("li",[v._v("显示内容字段含义\n"),t("ul",[t("li",[v._v("S0：年轻代中第一个Survivor区使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("S1：年轻代中第二个Survivor区使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("E：Eden区使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("O：老年代使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("M：元空间使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("CCS：压缩类使用大小占当前容量的百分比。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("YGCT：Young GC所用的时间。")]),v._v(" "),t("li",[v._v("FGC：Full GC的次数。")]),v._v(" "),t("li",[v._v("FGCT：Full GC的所用的时间。")]),v._v(" "),t("li",[v._v("GCT：GC的所用的总时间。")]),v._v(" "),t("li",[v._v("LGCC：上次垃圾回收的原因。")]),v._v(" "),t("li",[v._v("GCC：当前垃圾回收的原因")])])])]),v._v(" "),t("h4",{attrs:{id:"gcnew"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcnew"}},[v._v("#")]),v._v(" -gcnew")]),v._v(" "),t("ul",[t("li",[v._v("显示内容字段含义\n"),t("ul",[t("li",[v._v("S0C：年轻代中第一个Survivor区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S1C：年轻代中第二个Survivor区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S0U：年轻代中第一个Survivor区已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("S1U：年轻代中第二个Survivor区已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("TT：对象在年轻代存活的次数。")]),v._v(" "),t("li",[v._v("MTT：对象在年轻代存活的最大次数")]),v._v(" "),t("li",[v._v("DSS：期望的Survivor区大小，单位为KB。")]),v._v(" "),t("li",[v._v("EC：年轻代中Eden区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("EU：年轻代中Eden区已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("YGCT：Young GC所用的时间。")])])])]),v._v(" "),t("h4",{attrs:{id:"gcnewcapacity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcnewcapacity"}},[v._v("#")]),v._v(" -gcnewcapacity")]),v._v(" "),t("ul",[t("li",[v._v("显示内容字段含义\n"),t("ul",[t("li",[v._v("NGCMN：年轻代最小的容量，单位为KB。")]),v._v(" "),t("li",[v._v("NGCMX：年轻代最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("NGC：当前年轻代的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S0CMX：年轻代中第一个Survivor区最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S0C：年轻代中第一个Survivor区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S1CMX：年轻代中第二个Survivor区最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("S1C：年轻代中第二个Survivor区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("ECMX：年轻代中Eden区最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("EC：年轻代中Eden区的容量，单位为KB。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("FGC：Full GC的次数")])])])]),v._v(" "),t("h4",{attrs:{id:"gcold"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcold"}},[v._v("#")]),v._v(" -gcold")]),v._v(" "),t("ul",[t("li",[v._v("显示内容字段含义\n"),t("ul",[t("li",[v._v("MC：元空间的容量，单位为KB。")]),v._v(" "),t("li",[v._v("MU：元空间已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("CCSC：压缩类的容量，单位为KB。")]),v._v(" "),t("li",[v._v("CCSU：压缩类已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("OC：老年代的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OU：老年代已使用大小，单位为KB。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("FGC：Full GC的次数。")]),v._v(" "),t("li",[v._v("FGCT：Full GC的所用的时间。")]),v._v(" "),t("li",[v._v("GCT：GC的所用的总时间")])])])]),v._v(" "),t("h4",{attrs:{id:"gcoldcapacity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcoldcapacity"}},[v._v("#")]),v._v(" -gcoldcapacity")]),v._v(" "),t("ul",[t("li",[v._v("显示内容字段含义\n"),t("ul",[t("li",[v._v("OGCMN：老年代最小的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OGCMX：老年代最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OGC：当前老年代的容量，单位为KB。")]),v._v(" "),t("li",[v._v("OC：当前老年代的容量，单位为KB。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("FGC：Full GC的次数。")]),v._v(" "),t("li",[v._v("FGCT：Full GC的所用的时间。")]),v._v(" "),t("li",[v._v("GCT：GC的所用的总时间")])])])]),v._v(" "),t("h4",{attrs:{id:"gcmetacapacity"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcmetacapacity"}},[v._v("#")]),v._v(" -gcmetacapacity")]),v._v(" "),t("ul",[t("li",[v._v("显示内容字段含义\n"),t("ul",[t("li",[v._v("MCMN：元空间最小的容量，单位为KB。")]),v._v(" "),t("li",[v._v("MCMX：元空间最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("MC：当前元空间的容量，单位为KB。")]),v._v(" "),t("li",[v._v("CCSMN：压缩类最小的容量，单位为KB。")]),v._v(" "),t("li",[v._v("CCSMX：压缩类最大的容量，单位为KB。")]),v._v(" "),t("li",[v._v("YGC：Young GC的次数。")]),v._v(" "),t("li",[v._v("FGC：Full GC的次数。")]),v._v(" "),t("li",[v._v("FGCT：Full GC的所用的时间。")]),v._v(" "),t("li",[v._v("GCT：GC的所用的总时间")])])])]),v._v(" "),t("h4",{attrs:{id:"printcompilation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#printcompilation"}},[v._v("#")]),v._v(" -printcompilation")]),v._v(" "),t("ul",[t("li",[v._v("显示内容字段含义\n"),t("ul",[t("li",[v._v("Compiled：最近编译方法执行的编译任务的数量。")]),v._v(" "),t("li",[v._v("Size：最近编译方法的字节码的字节数。")]),v._v(" "),t("li",[v._v("Type：最近编译方法的编译类型。")]),v._v(" "),t("li",[v._v("Method：最近编译方法的类名和方法名")])])])]),v._v(" "),t("h3",{attrs:{id:"_3-3-分析jstat输出的工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-分析jstat输出的工具"}},[v._v("#")]),v._v(" 3.3 分析jstat输出的工具")]),v._v(" "),t("ul",[t("li",[v._v("像上面那样分析jstat的输出很不方便，太慢了，很多地方需要自己去换算单位去计算")]),v._v(" "),t("li",[v._v("为了方便分析可以使用gc分析工具："),t("a",{attrs:{href:"https://gceasy.io/",target:"_blank",rel:"noopener noreferrer"}},[v._v("gceasy"),t("OutboundLink")],1)]),v._v(" "),t("li",[v._v("它可以对gc日志进行分析，也可以对jstat等jvm命令的输出进行分析，可选择上传文件也可以选择Raw，粘贴文本的方式进行分析，点击Analyze即可。")])]),v._v(" "),t("h2",{attrs:{id:"_4-jinfo-java配置信息工具"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-jinfo-java配置信息工具"}},[v._v("#")]),v._v(" 4. jinfo (Java配置信息工具)")]),v._v(" "),t("ul",[t("li",[v._v("jinfo("),t("a",{attrs:{href:"https://so.csdn.net/so/search?q=Configuration&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[v._v("Configuration"),t("OutboundLink")],1),v._v(" Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数")])]),v._v(" "),t("h3",{attrs:{id:"_4-1-命令语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-命令语法"}},[v._v("#")]),v._v(" 4.1 命令语法")]),v._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[v._v("jinfo [options] pid\n")])]),v._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[v._v("1")]),t("br")])]),t("table",[t("thead",[t("tr",[t("th",[v._v("options")]),v._v(" "),t("th",[v._v("描述")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("no option")]),v._v(" "),t("td",[v._v("输出全部的参数和系统属性")])]),v._v(" "),t("tr",[t("td",[v._v("-flag name")]),v._v(" "),t("td",[v._v("输出对应名称的参数")])]),v._v(" "),t("tr",[t("td",[v._v("-flag [+|-]name")]),v._v(" "),t("td",[v._v("开启或者关闭对应名称的参数, 只有被标记为 manageable 的参数才可以被动态修改")])]),v._v(" "),t("tr",[t("td",[v._v("-flag name=value")]),v._v(" "),t("td",[v._v("设定对应名称的参数")])]),v._v(" "),t("tr",[t("td",[v._v("-flags")]),v._v(" "),t("td",[v._v("输出全部的参数")])]),v._v(" "),t("tr",[t("td",[v._v("-sysprops")]),v._v(" "),t("td",[t("strong",[v._v("输出系统属性(虚拟机进程的System.getProperties()的内容)")])])])])]),v._v(" "),t("h2",{attrs:{id:"_5-jconsole"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-jconsole"}},[v._v("#")]),v._v(" 5. jconsole")]),v._v(" "),t("ul",[t("li",[v._v("jconsole提供了一个用户友好的界面，允许开发者和系统管理员实时查看 JVM 的性能和资源使用情况")]),v._v(" "),t("li",[v._v("包括内存使用、线程活动、类加载情况、VM日志等")])]),v._v(" "),t("h2",{attrs:{id:"_6-jvisualvm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-jvisualvm"}},[v._v("#")]),v._v(" 6. jvisualvm")]),v._v(" "),t("ul",[t("li",[v._v("jvisualvm相比jconsole提供了更丰富的功能")])]),v._v(" "),t("h3",{attrs:{id:"_6-1-性能分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-性能分析"}},[v._v("#")]),v._v(" 6.1 性能分析")]),v._v(" "),t("ul",[t("li",[v._v("性能测试时可以使用进行 CPU 采样分析，识别性能瓶颈，了解主要在哪一块方法业务中耗时较久，进行针对优化")])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/liutao1996/images/main/picgo/image-20241105184009092.png",alt:"image-20241105184009092"}})])])}),[],!1,null,null,null);_.default=i.exports}}]);