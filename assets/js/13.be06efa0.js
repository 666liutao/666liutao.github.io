(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{444:function(t,a,r){"use strict";r.r(a);var s=r(6),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("div",{staticClass:"custom-block tip"},[r("ul",[r("li",[t._v("源码阅读")]),t._v(" "),r("li",[t._v("思考过程")])])]),t._v(" "),r("h1",{attrs:{id:"服务自检功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务自检功能"}},[t._v("#")]),t._v(" 服务自检功能")]),t._v(" "),r("h2",{attrs:{id:"功能介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#功能介绍"}},[t._v("#")]),t._v(" 功能介绍")]),t._v(" "),r("ul",[r("li",[t._v("A服务 提供一个健康检查接口,用于表示所有服务(A,B,C,D服务)的健康状态,以便网关进行流量切换")]),t._v(" "),r("li",[t._v("网关可以设置以下参数\n"),r("ul",[r("li",[t._v("探测间隔(一般为10s)")]),t._v(" "),r("li",[t._v("超时时间(通常与探测间隔一致)")]),t._v(" "),r("li",[t._v("如果超时时间10s,探测间隔为5s, 5s后不论上一次探测是否有结果,都会再发探测请求")])])]),t._v(" "),r("li",[t._v("网关探测到A机房的健康状态为DOWN时,将流量切换至其他机房")])]),t._v(" "),r("h2",{attrs:{id:"功能分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#功能分析"}},[t._v("#")]),t._v(" 功能分析")]),t._v(" "),r("ul",[r("li",[t._v("A服务自检接口所需要的时间 不能超过网关设置的超时时间\n"),r("ul",[r("li",[t._v("A服务自身的健康检查所耗时间")]),t._v(" "),r("li",[t._v("A服务服务远程访问其他服务(B,C,D)的健康状态所耗时间\n"),r("ul",[r("li",[t._v("当连接某个服务超时时,所耗时间以连接超时时间为准,若超时设置为10s，则自检接口至少需要10s,这种情况下会超过网关设置的超时时间")])])])])])]),t._v(" "),r("h2",{attrs:{id:"功能设计"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#功能设计"}},[t._v("#")]),t._v(" 功能设计")]),t._v(" "),r("ul",[r("li",[t._v("由于Spring自带的/actuator/health接口会实时检测服务的健康状态,自检时可能会出现超时情况")]),t._v(" "),r("li",[t._v("所以设计一个缓存状态,每次网关请求时,可以立马返回该状态,耗时最短\n"),r("ul",[r("li",[t._v("该缓存状态的刷新机制由定时任务去完成")]),t._v(" "),r("li",[t._v("A,B,C,D服务都做定时任务,每一个服务都有一个缓存状态,对外都提供一个/health接口")])])])]),t._v(" "),r("h2",{attrs:{id:"思路"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#思路"}},[t._v("#")]),t._v(" 思路")]),t._v(" "),r("ul",[r("li",[t._v("1.Spring已经自带了健康检查功能,自定义自检项继承AbstractHealthIndicator类即可")]),t._v(" "),r("li",[t._v("2.如自带的: RabbitHealthIndicator,NacosDiscoveryHealthIndicator等")]),t._v(" "),r("li",[t._v("3.访问/actuator/health,Spring即会找到所有的HealthIndicator类,逐项检查,汇总结果")]),t._v(" "),r("li",[t._v("4.我们的任务只要在定时任务中去手动触发Spring自检即可,并刷新服务健康状态的缓存")])]),t._v(" "),r("h3",{attrs:{id:"如何手动触发spring自检"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何手动触发spring自检"}},[t._v("#")]),t._v(" 如何手动触发Spring自检")]),t._v(" "),r("ul",[r("li",[t._v("通过阅读Spring自检源码来了解Spring是如何做健康检查的")]),t._v(" "),r("li",[r("a",{attrs:{href:"https://blog.csdn.net/shengqianfeng/article/details/115112070",target:"_blank",rel:"noopener noreferrer"}},[t._v("SpringBoot健康检查源码走读"),r("OutboundLink")],1)])]),t._v(" "),r("h3",{attrs:{id:"实现代码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现代码"}},[t._v("#")]),t._v(" 实现代码")]),t._v(" "),r("ul",[r("li",[t._v("定时任务.")])]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code")]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"})]),r("h2",{attrs:{id:"过程中遇到的问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#过程中遇到的问题"}},[t._v("#")]),t._v(" 过程中遇到的问题")]),t._v(" "),r("ul",[r("li",[t._v("配置文件自检时 所有项显示为 不能为空")]),t._v(" "),r("li",[t._v("FeignClient指定URL调用")])])])}),[],!1,null,null,null);a.default=i.exports}}]);